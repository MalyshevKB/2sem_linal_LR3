## Отчёт по лабораторной работе №3
**"Реализация квантовых гейтов"**  

---

#### **1. Реализация кубита**  
Класс `Qubit` представляет состояние кубита с использованием вектора в двумерном комплексном пространстве$({C}^2)$:  
```python
class Qubit:
    def __init__(self, alpha=1, beta=0):
        self.state = np.array([alpha, beta], dtype=complex)
        self.normalize()
```  
- **Состояние**: $(\alpha|0\rangle + \beta|1\rangle)$
- **Нормализация**: Гарантирует $(|\alpha|^2 + |\beta|^2 = 1)$ через метод `normalize()`(вероятность в пределе 1).  
- **Исключение**: При `alpha=0, beta=0` возникает ошибка деления на ноль.  

---

#### **2. Однокубитные гейты Паули**  
Реализованы как унитарные матрицы $(2 \times 2)$:  

1. **Гейт X (NOT-оператор)**  
   ```python
   X = np.array([[0, 1], [1, 0]])
   ```  
   - Математическое представление:  
    ```math
    X = \begin{pmatrix} 0 && 1 \\ 1 && 0 \end{pmatrix} 
    ```
   - Действие: $(X|0\rangle = |1\rangle), (X|1\rangle = |0\rangle)$.  

2. **Гейт Y**  
   ```python
   Y = np.array([[0, -1j], [1j, 0]])
   ```  
   - Математическое представление:  
    ```math 
    Y = \begin{pmatrix}0 && -i \\i && 0\end{pmatrix} 
    ```
   - Действие: Поворот на $(\pi)$ вокруг оси Y на сфере Блоха.  

3. **Гейт Z (Фазовый сдвиг)**  
   ```python
   Z = np.array([[1, 0], [0, -1]])
   ```  
   - Математическое представление:  
    ```math
    Z = \begin{pmatrix}1 && 0 \\0 && -1\end{pmatrix}
    ```
   - Действие: $(Z|0\rangle = |0\rangle), (Z|1\rangle = -|1\rangle)$.  

**Применение гейтов**:  
```python
q.apply_gate(X)  # Применяет гейт к кубиту
```

---

#### **3. Двухкубитные системы**  
Класс `TwoQubit` реализует систему из двух кубитов:  
```python
class TwoQubit:
    def __init__(self, state=None):
        self.state = state or np.array([1, 0, 0, 0], dtype=complex)
        self.normalize()
```  
- **Начальное состояние**: 
```math
(|00\rangle = \begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix})
```
- **Нормализация**: Аналогично однокубитному случаю.  

---

#### **4. Гейт CNOT (Controlled-NOT)**  
Реализация через матрицу $(4 \times 4)$:  
```python
cnot_matrix = np.array([
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1],
    [0, 0, 1, 0]
])
```  
- Математическое представление:  
  
  ```math
  CNOT = \begin{pmatrix}
    1 && 0 && 0 && 0 \\
    0 && 1 && 0 && 0 \\
    0 && 0 && 0 && 1 \\
    0 && 0 && 1 && 0
    \end{pmatrix} 
    ```
- **Действие**:  
  - Если первый кубит $(|0\rangle)$: второй не меняется.  
  - Если первый кубит $(|1\rangle)$: ко второму применяется X.  
  Пример: $(\text{CNOT}|10\rangle = |11\rangle)$.  

**Применение**:  
```python
sys.apply_cnot()  # Применяет CNOT к системе
```

---

#### **5. Пример использования**  
```python
# Создание кубита |0>
q = Qubit(1, 0)  
print("До X:", q.state)  # [1, 0]

# Применение гейта X
q.apply_gate(X)  
print("После X:", q.state)  # [0, 1]

# Создание системы двух кубитов |00>
sys = TwoQubit()  
sys.apply_cnot()
print("После CNOT:", sys.state)  # [1, 0, 0, 0] (без изменений)
```

---

